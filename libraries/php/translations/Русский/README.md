# SA-MP Query - PHP

<div align="center">

![PHP](https://img.shields.io/badge/PHP-8.1%2B-777BB4?style=for-the-badge&logo=php&logoColor=white)
![Architecture](https://img.shields.io/badge/Protocol-UDP-blueviolet?style=for-the-badge)
![License](https://img.shields.io/badge/License-MIT-green?style=for-the-badge)

**Надежная и отказоустойчивая PHP-библиотека, разработанная для запроса состояния и информации с серверов SA-MP (San Andreas Multiplayer) и OMP (Open Multiplayer).**

</div>

## Языки

- Português: [README](../../)
- Deutsch: [README](../Deutsch/README.md)
- English: [README](../English/README.md)
- Español: [README](../Espanol/README.md)
- Français: [README](../Francais/README.md)
- Italiano: [README](../Italiano/README.md)
- Polski: [README](../Polski/README.md)
- Svenska: [README](../Svenska/README.md)
- Türkçe: [README](../Turkce/README.md)

## Содержание

- [SA-MP Query - PHP](#sa-mp-query---php)
  - [Языки](#языки)
  - [Содержание](#содержание)
  - [Обзор](#обзор)
  - [Принципы проектирования и архитектура](#принципы-проектирования-и-архитектура)
    - [Модульная архитектура](#модульная-архитектура)
    - [Отказоустойчивость: Backoff, повторные попытки и кэширование](#отказоустойчивость-backoff-повторные-попытки-и-кэширование)
    - [Оптимизация производительности: Параллелизм и адаптация тайм-аута](#оптимизация-производительности-параллелизм-и-адаптация-тайм-аута)
    - [Современное объектно-ориентированное программирование (OOP) (PHP 8.1+)](#современное-объектно-ориентированное-программирование-oop-php-81)
  - [Требования](#требования)
  - [Установка и базовое использование](#установка-и-базовое-использование)
    - [Инициализация класса `Samp_Query`](#инициализация-класса-samp_query)
    - [`Get_All()`: Полный и оптимизированный запрос](#get_all-полный-и-оптимизированный-запрос)
    - [`Is_Online()`: Быстрая проверка статуса](#is_online-быстрая-проверка-статуса)
    - [`Get_Ping()`: Получение пинга сервера](#get_ping-получение-пинга-сервера)
    - [`Get_Info()`: Основные данные о сервере](#get_info-основные-данные-о-сервере)
    - [`Get_Rules()`: Настроенные правила сервера](#get_rules-настроенные-правила-сервера)
    - [`Get_Players_Detailed()`: Список игроков с подробностями](#get_players_detailed-список-игроков-с-подробностями)
    - [`Get_Players_Basic()`: Базовый список игроков](#get_players_basic-базовый-список-игроков)
    - [`Send_Rcon()`: Отправка удаленных команд](#send_rcon-отправка-удаленных-команд)
  - [Подробная структура библиотеки и поток выполнения](#подробная-структура-библиотеки-и-поток-выполнения)
    - [1. `constants.php`: Сердце конфигурации](#1-constantsphp-сердце-конфигурации)
    - [2. `opcode.php`: Enum опкодов протокола](#2-opcodephp-enum-опкодов-протокола)
    - [3. `exceptions.php`: Иерархия пользовательских исключений](#3-exceptionsphp-иерархия-пользовательских-исключений)
    - [4. `server_types.php`: Неизменяемые модели данных](#4-server_typesphp-неизменяемые-модели-данных)
    - [5. `autoloader.php`: Автоматический загрузчик классов](#5-autoloaderphp-автоматический-загрузчик-классов)
    - [6. `logger.php`: Подсистема логирования](#6-loggerphp-подсистема-логирования)
    - [7. `domain_resolver.php`: Разрешение доменов с постоянным кэшем](#7-domain_resolverphp-разрешение-доменов-с-постоянным-кэшем)
    - [8. `socket_manager.php`: Надежный менеджер UDP-соединений](#8-socket_managerphp-надежный-менеджер-udp-соединений)
    - [9. `packet_builder.php`: Сборщик бинарных пакетов](#9-packet_builderphp-сборщик-бинарных-пакетов)
    - [10. `packet_parser.php`: Декодер пакетов с обработкой кодировки](#10-packet_parserphp-декодер-пакетов-с-обработкой-кодировки)
    - [11. `samp-query.php`: Основной класс (Полный оркестратор)](#11-samp-queryphp-основной-класс-полный-оркестратор)
      - [Жизненный цикл запроса: Путешествие пакета](#жизненный-цикл-запроса-путешествие-пакета)
        - [1. Инициализация и разрешение домена](#1-инициализация-и-разрешение-домена)
        - [2. `Fetch_Server_State()`: Кэш и критический запрос INFO/PING](#2-fetch_server_state-кэш-и-критический-запрос-infoping)
        - [3. `Attempt_Query()`: Оптимизированная стратегия повторных попыток](#3-attempt_query-оптимизированная-стратегия-повторных-попыток)
        - [4. `Execute_Query_Phase()`: Движок связи с определением пинга](#4-execute_query_phase-движок-связи-с-определением-пинга)
        - [5. `Validate_Response()`: Слой семантической валидации](#5-validate_response-слой-семантической-валидации)
      - [Расчет и управление адаптивным тайм-аутом](#расчет-и-управление-адаптивным-тайм-аутом)
      - [Публичные методы запросов](#публичные-методы-запросов)
      - [Связь RCON (`Send_Rcon`)](#связь-rcon-send_rcon)
  - [Диагностика ошибок и исключений](#диагностика-ошибок-и-исключений)
    - [`Invalid_Argument_Exception`](#invalid_argument_exception)
    - [`Connection_Exception`](#connection_exception)
    - [`Malformed_Packet_Exception`](#malformed_packet_exception)
    - [`Rcon_Exception`](#rcon_exception)
  - [Лицензия](#лицензия)
    - [Условия использования](#условия-использования)
      - [1. Предоставленные разрешения](#1-предоставленные-разрешения)
      - [2. Обязательные условия](#2-обязательные-условия)
      - [3. Авторские права](#3-авторские-права)
      - [4. Отказ от гарантий и ограничение ответственности](#4-отказ-от-гарантий-и-ограничение-ответственности)

## Обзор

Библиотека **SA-MP Query - PHP** — это высокопроизводительное и отказоустойчивое решение для PHP-разработчиков, которым необходимо взаимодействовать с игровыми серверами на основе протокола SA-MP/OMP (UDP). Её цель — инкапсулировать сложность бинарного протокола запросов в чистый и интуитивно понятный PHP API, позволяя веб-приложениям, лаунчерам и утилитам быстро и надежно получать подробную информацию о состоянии сервера (игроки, правила, пинг и т.д.).

Дизайн библиотеки сфокусирован на трех основных принципах: **Отказоустойчивость**, **Производительность** и **Модульность**. Она создана для работы с ненадежной природой протокола UDP, реализуя продвинутую систему повторных попыток и *backoff*, чтобы гарантировать получение информации даже в неблагоприятных сетевых условиях или на серверах с высокой задержкой.

## Принципы проектирования и архитектура

### Модульная архитектура

Библиотека разделена на компоненты с единой ответственностью, каждый из которых инкапсулирован в своем собственном классе и файле.

- **Сетевая инфраструктура:** `Domain_Resolver`, `Socket_Manager`.
- **Протокол:** `Packet_Builder`, `Packet_Parser`, `Opcode` (Enum).
- **Бизнес-логика (Оркестрация):** `Samp_Query`.
- **Модели данных:** `Server_Info`, `Players_Detailed` и т.д.

### Отказоустойчивость: Backoff, повторные попытки и кэширование

Протокол UDP не гарантирует доставку пакетов. Класс `Samp_Query` смягчает этот недостаток с помощью сложного цикла запросов.

- **Множественные адаптивные попытки:** Метод `Attempt_Query` реализует цикл с `Query::ATTEMPTS` (по умолчанию 5) попытками и вдвое большим количеством для критических запросов.
- **Стратегия Backoff:** Экспоненциальный *backoff* реализован в `Execute_Query_Phase`. После первой отправки интервал новых попыток прослушивания (цикл `while`) увеличивается с `Performance::INITIAL_RETRY_INTERVAL` (0.08 с) на `Performance::BACKOFF_FACTOR` (1.3) до предела в 0.2 с. Это предотвращает перегрузку пакетами и увеличивает шанс на своевременный ответ.
- **Кэширование ответов:** Последние ответы (действительны в течение 2.0 секунд) сохраняются в `response_cache`, устраняя необходимость повторять запросы метаданных во время выполнения `Get_All()`.

### Оптимизация производительности: Параллелизм и адаптация тайм-аута

- **Параллельные запросы (Fan-out):** Метод `Get_All()` отправляет запросы на `INFO`, `RULES` и `PLAYERS` одновременно (в `$jobs`), позволяя ответам приходить в произвольном порядке, минимизируя общее время ожидания.
- **Постоянное кэширование DNS:** `Domain_Resolver` сохраняет разрешенный IP-адрес в локальном файловом кэше с TTL 3600 секунд, избегая задержек при разрешении домена в последующих вызовах.
- **Адаптивный тайм-аут:** Тайм-аут для запросов больших данных (например, списка игроков) динамически настраивается на основе `cached_ping` сервера:
   ```
   Настроенный тайм-аут = Базовый тайм-аут + (Кэшированный пинг * Множитель пинга / 1000)
   ```
   Эта логика (реализованная в `Fetch_Player_Data`) гарантирует, что у серверов с высокой задержкой будет достаточно времени для ответа, не снижая скорости на серверах с низкой задержкой.

### Современное объектно-ориентированное программирование (OOP) (PHP 8.1+)

Библиотека использует современные возможности PHP для обеспечения безопасности и ясности:

- **Строгая типизация** (`declare(strict_types=1)`).
- **Свойства только для чтения** (`public readonly` в `Samp_Query` и моделях данных) для обеспечения неизменяемости данных.
- **Типизированные Enums** (`enum Opcode: string`) для безопасного управления протоколом.
- **Constructor Property Promotion** (в `Samp_Query::__construct` и моделях).

## Требования

- **PHP:** Версия **8.1 или выше**.
- **Расширения PHP:** `sockets` и `mbstring` (для работы с кодировкой UTF-8).

## Установка и базовое использование

Чтобы начать использовать библиотеку **SA-MP Query - PHP**, просто подключите файл `samp-query.php` в свой проект. Этот файл автоматически загрузит все зависимости через свой внутренний автозагрузчик.

```php
<?php
// Подключите основной класс. Он позаботится о загрузке зависимостей через автозагрузчик.
require_once 'path/to/samp-query/samp-query.php'; 

// Используйте пространство имен основного класса
use Samp_Query\Samp_Query;
// Подключите исключения для более специфической обработки ошибок
use Samp_Query\Exceptions\Invalid_Argument_Exception;
use Samp_Query\Exceptions\Connection_Exception;
use Samp_Query\Exceptions\Rcon_Exception;

// Создайте экземпляр класса Samp_Query, обернув его в блок try-catch для обработки ошибок инициализации.
try {
    $server_query = new Samp_Query("play.example-samp-server.com", 7777);
    // Теперь вы можете использовать публичные методы $server_query
}
catch (Invalid_Argument_Exception $e) {
    echo "Ошибка аргумента: " . $e->getMessage() . "\n";
}
catch (Connection_Exception $e) {
    echo "Ошибка подключения: " . $e->getMessage() . "\n";
}
catch (\Exception $e) {
    echo "Неожиданная ошибка во время инициализации: " . $e->getMessage() . "\n";
}
```

### Инициализация класса `Samp_Query`

Класс `Samp_Query` является точкой входа для всех функций. Его конструктор требует `hostname` (или IP-адрес) и `port` сервера, который вы хотите опросить.

```php
/**
 * Инициализирует новый экземпляр библиотеки Samp_Query.
 *
 * @param string $hostname Имя хоста или IP-адрес сервера SA-MP/OMP.
 * @param int $port UDP-порт сервера (обычно 7777).
 * 
 * @throws Invalid_Argument_Exception Если имя хоста пустое или порт недействителен.
 * @throws Connection_Exception Если не удается разрешить DNS или создать сокет.
 */
public function __construct(public readonly string $hostname, public readonly int $port)
```

<br>

---

### `Get_All()`: Полный и оптимизированный запрос

Это наиболее полный и рекомендуемый метод. Он выполняет несколько запросов (INFO, RULES, PLAYERS) параллельно и оптимизированно, минимизируя общее время ответа и возвращая полный ассоциативный массив со всей доступной информацией.

```php
/**
 * Возвращает всю доступную информацию о сервере в одном оптимизированном вызове.
 * Включает: is_online, ping, info (Server_Info), rules (массив Server_Rule),
 * players_detailed (массив Players_Detailed), players_basic (массив Players_Basic),
 * и execution_time_ms.
 *
 * @return array Ассоциативный массив, содержащий всю информацию о сервере.
 * 
 * @throws Connection_Exception Если запрос INFO, необходимый для определения состояния сервера, не удался.
 */
public function Get_All(): array
```

Пример использования:

```php
<?php
// ... (инициализация класса $server_query) ...

try {
    $data = $server_query->Get_All();
    
    if ($data['is_online']) {
        echo "## Сервер онлайн: {$data['info']->hostname} ({$server_query->ip}:{$server_query->port}) ##\n";
        echo "Пинг: {$data['ping']}ms | Общее время запроса: {$data['execution_time_ms']}ms\n";
        echo "Игроки: {$data['info']->players} / {$data['info']->max_players}\n";
        echo "Игровой режим: {$data['info']->gamemode}\n";
        echo "Язык: {$data['info']->language}\n";
        echo "Защищен паролем: " . ($data['info']->password ? "Да" : "Нет") . "\n\n";

        // Пример подробного списка игроков
        if (!empty($data['players_detailed'])) {
            echo "--- Подробный список игроков ({$data['info']->players} онлайн) ---\n";

            foreach ($data['players_detailed'] as $player)
                echo "ID: {$player->id}, Имя: {$player->name}, Пинг: {$player->ping}ms, Счет: {$player->score}\n";
        }
        elseif (!empty($data['players_basic'])) {
            echo "--- Базовый список игроков ({$data['info']->players} онлайн) (Резервный вариант) ---\n";

            foreach ($data['players_basic'] as $player)
                echo "Имя: {$player->name}, Счет: {$player->score}\n";
        }
        else
            echo "Нет игроков онлайн или список недоступен (возможно, слишком много игроков).\n";
        
        // Пример правил сервера
        if (!empty($data['rules'])) {
            echo "\n--- Правила сервера ---\n";

            foreach ($data['rules'] as $rule)
                echo "{$rule->name}: {$rule->value}\n";
        }
    }
    else
        echo "Сервер в настоящее время оффлайн или недоступен.\n";
}
catch (Connection_Exception $e) {
    echo "Ошибка подключения при попытке получить всю информацию: " . $e->getMessage() . "\n";
}
catch (\Exception $e) {
    echo "Неожиданная ошибка при запросе всей информации: " . $e->getMessage() . "\n";
}
```

<br>

---

### `Is_Online()`: Быстрая проверка статуса

Проверяет, находится ли сервер в сети и отвечает ли на запросы, не запрашивая дополнительных сведений. Идеально для простой "проверки жизнеспособности".

```php
/**
 * Проверяет, находится ли сервер в сети и доступен ли он.
 *
 * @return bool Возвращает true, если сервер в сети и отвечает действительной информацией INFO, в противном случае false.
 */
public function Is_Online(): bool
```

Пример использования:

```php
<?php
// ... (инициализация класса $server_query) ...

if ($server_query->Is_Online())
    echo "Сервер SA-MP в сети и отвечает!\n";
else
    echo "Сервер SA-MP оффлайн или не ответил вовремя.\n";
```

<br>

---

### `Get_Ping()`: Получение пинга сервера

Возвращает время задержки (пинг) сервера в миллисекундах. Это значение кэшируется внутри для оптимизации.

```php
/**
 * Возвращает текущий пинг сервера в миллисекундах.
 * Если пинг еще не рассчитан, будет выполнен быстрый PING-запрос.
 *
 * @return int|null Значение пинга в миллисекундах или null, если его невозможно получить.
 */
public function Get_Ping(): ?int
```

Пример использования:

```php
<?php
// ... (инициализация класса $server_query) ...

try {
    $ping = $server_query->Get_Ping();

    if ($ping !== null)
        echo "Пинг сервера: {$ping}ms.\n";
    else
        echo "Не удалось получить пинг сервера.\n";
}
catch (Connection_Exception $e) {
    echo "Ошибка при получении пинга: " . $e->getMessage() . "\n";
}
```

<br>

---

### `Get_Info()`: Основные данные о сервере

Получает основную информацию о сервере, такую как имя хоста, игровой режим, количество игроков и т.д. Возвращает объект `Server_Info`.

```php
/**
 * Возвращает основные сведения о сервере (имя хоста, игроки, игровой режим и т.д.).
 * Данные кэшируются на короткий период для оптимизации.
 *
 * @return Server_Info|null Объект Server_Info или null, если информацию получить не удалось.
 */
public function Get_Info(): ?Server_Info
```

Пример использования:

```php
<?php
use Samp_Query\Models\Server_Info;
// ... (инициализация класса $server_query) ...

try {
    /** @var Server_Info|null $info */
    $info = $server_query->Get_Info();

    if ($info) {
        echo "--- Информация о сервере ---\n";
        echo "Имя хоста: {$info->hostname}\n";
        echo "Игровой режим: {$info->gamemode}\n";
        echo "Игроки: {$info->players} / {$info->max_players}\n";
        echo "Язык: {$info->language}\n";
        echo "Защищен паролем: " . ($info->password ? "Да" : "Нет") . "\n";
    }
    else
        echo "Не удалось получить информацию о сервере.\n";
}
catch (Connection_Exception $e) {
    echo "Ошибка при получении информации о сервере: " . $e->getMessage() . "\n";
}
```

<br>

---

### `Get_Rules()`: Настроенные правила сервера

Получает все настроенные на сервере правила, такие как `mapname`, `weburl`, `weather` и т.д., возвращая их в виде массива объектов `Server_Rule`.

```php
/**
 * Возвращает массив объектов Server_Rule, каждый из которых содержит имя и значение правила сервера.
 * Данные кэшируются для оптимизации.
 *
 * @return array Массив Samp_Query\Models\Server_Rule. Может быть пустым, если правил нет.
 */
public function Get_Rules(): array
```

Пример использования:

```php
<?php
use Samp_Query\Models\Server_Rule;
// ... (инициализация класса $server_query) ...

try {
    $rules = $server_query->Get_Rules();

    if (!empty($rules)) {
        echo "--- Правила сервера ---\n";

        foreach ($rules as $rule)
            echo "{$rule->name}: {$rule->value}\n";

        // Пример доступа к конкретному правилу:
        $mapname_rule = array_filter($rules, fn(Server_Rule $r) => $r->name === 'mapname');

        if (!empty($mapname_rule))
            echo "\nТекущая карта: " . reset($mapname_rule)->value . "\n";
    }
    else
        echo "Правила для этого сервера не найдены.\n";
}
catch (Connection_Exception $e) {
    echo "Ошибка при получении правил сервера: " . $e->getMessage() . "\n";
}
```

<br>

---

### `Get_Players_Detailed()`: Список игроков с подробностями

Получает подробный список игроков, находящихся в данный момент в сети, включая ID, имя, счет и пинг.

> [!CAUTION]
> Для оптимизации производительности и избежания чрезмерно больших пакетов UDP, которые могут быть потеряны или фрагментированы, этот метод не будет запрашивать подробный список игроков, если общее количество игроков равно или превышает `Query::LARGE_PLAYER_THRESHOLD` (по умолчанию 150). В таких случаях будет возвращен пустой массив. Рассмотрите возможность использования `Get_Players_Basic()` в качестве резервного варианта.

```php
/**
 * Возвращает массив объектов Players_Detailed (ID, имя, счет, пинг) для каждого игрока онлайн.
 * Этот запрос может быть проигнорирован, если количество игроков слишком велико (см. Query::LARGE_PLAYER_THRESHOLD).
 *
 * @return array Массив Samp_Query\Models\Players_Detailed. Может быть пустым.
 */
public function Get_Players_Detailed(): array
```

Пример использования:

```php
<?php
use Samp_Query\Models\Players_Detailed;
// ... (инициализация класса $server_query) ...

try {
    $players_detailed = $server_query->Get_Players_Detailed();

    if (!empty($players_detailed)) {
        echo "--- Игроки онлайн (подробно) ---\n";

        foreach ($players_detailed as $player)
            echo "ID: {$player->id}, Имя: {$player->name}, Счет: {$player->score}, Пинг: {$player->ping}ms\n";
    }
    else
        echo "Нет игроков онлайн или подробный список недоступен.\n";
}
catch (Connection_Exception $e) {
    echo "Ошибка при получении подробного списка игроков: " . $e->getMessage() . "\n";
}
```

<br>

---

### `Get_Players_Basic()`: Базовый список игроков

Предоставляет более легкий список игроков, содержащий только имя и счет. Полезно в качестве альтернативы, когда подробный список недоступен, или для уменьшения объема данных.

```php
/**
 * Возвращает массив объектов Players_Basic (имя, счет) для каждого игрока онлайн.
 * Полезно в качестве более легкой альтернативы или резервного варианта, когда Get_Players_Detailed() нецелесообразен.
 *
 * @return array Массив Samp_Query\Models\Players_Basic. Может быть пустым.
 */
public function Get_Players_Basic(): array
```

Пример использования:

```php
<?php
use Samp_Query\Models\Players_Basic;
// ... (инициализация класса $server_query) ...

try {
    $players_basic = $server_query->Get_Players_Basic();

    if (!empty($players_basic)) {
        echo "--- Игроки онлайн (базовый) ---\n";

        foreach ($players_basic as $player)
            echo "Имя: {$player->name}, Счет: {$player->score}\n";
    }
    else
        echo "Нет игроков онлайн или базовый список недоступен.\n";
}
catch (Connection_Exception $e) {
    echo "Ошибка при получении базового списка игроков: " . $e->getMessage() . "\n";
}
```

<br>

---

### `Send_Rcon()`: Отправка удаленных команд

Позволяет отправлять команды в RCON-консоль сервера, например, для изменения правил, бана игроков и т.д. Требуется RCON-пароль сервера.

> [!WARNING]
> Функция RCON чувствительна и может вызывать изменения на сервере. Используйте с осторожностью и только с доверенными паролями.
> Крайне важно, чтобы RCON-пароль был **правильным** и RCON был **включен** на сервере (настройка `rcon_password` в `server.cfg`).

```php
/**
 * Отправляет RCON-команду на сервер.
 * Выполняет аутентификацию с 'varlist' и отправляет команду.
 *
 * @param string $rcon_password RCON-пароль сервера.
 * @param string $command Команда для выполнения (например, "gmx", "kick ID").
 * @return string Ответ сервера на RCON-команду или сообщение о статусе.
 * 
 * @throws Invalid_Argument_Exception Если RCON-пароль или команда пустые.
 * @throws Rcon_Exception Если аутентификация RCON не удалась или команда не получила ответа.
 * @throws Connection_Exception В случае сбоя подключения во время операции RCON.
 */
public function Send_Rcon(string $rcon_password, string $command): string
```

Пример использования:

```php
<?php
// ... (инициализация класса $server_query) ...

$rcon_password = "ваш_секретный_пароль_здесь"; 
$command_to_send = "gmx"; // Пример: перезапуск игрового режима

try {
    echo "Попытка отправить RCON-команду: '{$command_to_send}'...\n";
    $response = $server_query->Send_Rcon($rcon_password, $command_to_send);
    echo "Ответ RCON: {$response}\n";

    // Пример команды для "сказать" что-то на сервере (требуется RCON)
    $response_say = $server_query->Send_Rcon($rcon_password, "say Привет из моего PHP-скрипта!");
    echo "Ответ RCON (say): {$response_say}\n";
}
catch (Invalid_Argument_Exception $e) {
    echo "Ошибка RCON (Неверный аргумент): " . $e->getMessage() . "\n";
}
catch (Rcon_Exception $e) {
    echo "Ошибка RCON: Сбой аутентификации или команда не выполнена. " . $e->getMessage() . "\n";
}
catch (Connection_Exception $e) {
    echo "Ошибка RCON (Подключение): " . $e->getMessage() . "\n";
}
catch (\Exception $e) {
    echo "Неожиданная ошибка при отправке RCON: " . $e->getMessage() . "\n";
}
```

## Подробная структура библиотеки и поток выполнения

Библиотека **SA-MP Query - PHP** тщательно организована в несколько файлов, каждый из которых имеет четко определенную ответственность. В этом разделе подробно рассматривается каждый компонент, раскрывая дизайнерские решения и лежащую в основе логику.

### 1. `constants.php`: Сердце конфигурации

Этот файл централизует все "магические" параметры конфигурации библиотеки, обеспечивая легкую настройку и согласованность таких аспектов, как *тайм-ауты*, количество попыток и размеры буферов по всему проекту.

```php
// ...
final class Query {
    public const ATTEMPTS = 5; // Максимальное количество попыток запроса
    public const LARGE_PLAYER_THRESHOLD = 150; // Лимит игроков для подробного запроса
}

final class Protocol {
    public const UDP_READ_BUFFER_SIZE = 32768; // 32KB для буфера чтения
    public const KERNEL_RECEIVE_BUFFER_SIZE = 4194304; // 4MB для буфера ядра
}
// ...
```

- **Final Classes и константы:** Классы являются `final`, а свойства — `public const`, что обеспечивает неизменяемость и глобальную доступность во время компиляции.
- **Гранулярность и семантика:** Константы сгруппированы по их области применения (`Query`, `Protocol`, `Performance`, `Logger`, `DNS`), что облегчает понимание и обслуживание. Например, `Query::LARGE_PLAYER_THRESHOLD` определяет порог, при котором можно избежать запроса подробных списков игроков для оптимизации из-за большого объема данных и потенциальных *тайм-аутов*.

### 2. `opcode.php`: Enum опкодов протокола

Этот файл определяет операционные коды (опкоды), используемые для различных запросов к серверу SA-MP/OMP, инкапсулируя их в типизированный `enum`.

```php
// ...
enum Opcode: string {
    case INFO = 'i';
    case RULES = 'r';
    case PLAYERS_DETAILED = 'd';
    // ...
}
```

- **Типизированный `Enum` (PHP 8.1+):** Использование `enum` (`Opcode: string`) со значениями типа `string` гарантирует, что опкоды всегда будут действительными и код будет семантически ясным. Это заменяет использование "магических" строковых литералов, делая код более читабельным и менее подверженным опечаткам.

### 3. `exceptions.php`: Иерархия пользовательских исключений

Этот файл устанавливает иерархию пользовательских исключений, позволяя более гранулярно и специфично обрабатывать различные типы сбоев, которые могут произойти в библиотеке.

```php
// ...
class Query_Exception extends \Exception {}
class Invalid_Argument_Exception extends Query_Exception {}
class Connection_Exception extends Query_Exception {}
// ...
```

- **Наследование от `\Exception`:** Все исключения наследуются от `Query_Exception` (которое, в свою очередь, расширяет `\Exception`), что позволяет перехватывать группы ошибок (`Connection_Exception` и `Timeout_Exception` более специфичны, чем `Query_Exception`) или все исключения библиотеки с помощью более общего `catch`.
- **Ясность в диагностике:** Описательные имена исключений облегчают диагностику и восстановление после ошибок в клиентском приложении.

### 4. `server_types.php`: Неизменяемые модели данных

Этот файл определяет классы, которые представляют модели данных для информации, возвращаемой сервером, обеспечивая целостность данных через неизменяемость.

```php
// ...
final class Server_Info {
    public function __construct(
        public readonly bool $password,
        public readonly int $players,
        // ... другие readonly свойства ...
    ) {}
}
// ...
```

- **`final class`:** Классы являются `final`, что предотвращает их расширение и гарантирует их структуру и поведение.
- **`public readonly` Properties (PHP 8.1+):** Все свойства объявлены как `public readonly`. Это означает, что после создания объекта его значения не могут быть изменены, что гарантирует целостность данных, полученных от сервера.
- **Constructor Property Promotion (PHP 8.1+):** Свойства объявляются непосредственно в конструкторе, что упрощает код и уменьшает *boilerplate*.

### 5. `autoloader.php`: Автоматический загрузчик классов

Этот файл отвечает за динамическую загрузку классов библиотеки по мере их необходимости, следуя стандарту PSR-4.

```php
// ...
spl_autoload_register(function ($class) {
    $prefix = 'Samp_Query\\';
    $base_dir = __DIR__ . '/../modules/'; // Сопоставляет пространство имен с каталогом
    // ... логика загрузки ...
});

// Подключает важные файлы, которые не являются классами или требуют предварительной загрузки
require_once __DIR__ . '/../modules/constants.php';
require_once __DIR__ . '/../modules/exceptions.php';
// ...
```

- **`spl_autoload_register()`:** Регистрирует анонимную функцию, которая автоматически вызывается PHP при обращении к неопределенному классу, ускоряя разработку и обслуживание.
- **Прямое подключение конфигураций:** Файлы, такие как `constants.php` и `exceptions.php`, подключаются напрямую. Это гарантирует, что их определения будут доступны до того, как любой использующий их класс будет инстанцирован автозагрузчиком.

### 6. `logger.php`: Подсистема логирования

Класс `Logger` предоставляет простой механизм для записи сообщений об ошибках и важных событий в файл лога, что полезно для отладки и мониторинга.

```php
// ...
final class Logger {
    public function Log(string $message): void {
        if (is_file(Logger_Config::FILE) && filesize(Logger_Config::FILE) > Logger_Config::MAX_SIZE_BYTES)
            unlink(Logger_Config::FILE); // Удаляет лог, если он превышает размер

        $timestamp = date('Y-m-d H:i:s');
        $log_entry = "[{$timestamp}] {$message}" . PHP_EOL;
        
        file_put_contents(Logger_Config::FILE, $log_entry, FILE_APPEND | LOCK_EX); // Добавляет с блокировкой
    }
}
```

- **Автоматическая очистка:** Логгер проверяет размер файла лога (`Logger_Config::FILE`). Если он превышает `Logger_Config::MAX_SIZE_BYTES` (по умолчанию 10 МБ), файл удаляется, чтобы предотвратить его бесконечный рост.
- **Блокировка файла (`LOCK_EX`):** `file_put_contents` использует `LOCK_EX` для обеспечения того, чтобы только один процесс мог одновременно записывать в файл лога, предотвращая повреждение данных в многопоточных/многопроцессных средах.

### 7. `domain_resolver.php`: Разрешение доменов с постоянным кэшем

Класс `Domain_Resolver` отвечает за преобразование имен хостов (например, `play.example.com`) в IP-адреса (например, `192.0.2.1`). Он реализует систему кэширования на диске для оптимизации производительности.

```php
// ...
final class Domain_Resolver {
    public function Resolve(string $hostname): string {
        if (filter_var($hostname, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4))
            return $hostname; // Уже является IP

        $cache_file = DNS_Config::CACHE_DIR . md5($hostname) . '.cache';

        if (file_exists($cache_file) && (time() - filemtime($cache_file)) < DNS_Config::CACHE_TTL_SECONDS) {
            $ip = file_get_contents($cache_file);

            if ($ip && filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4))
                return $ip;
        }
        
        $ip = gethostbyname($hostname); // Реальное разрешение DNS
        // ... логика валидации и сохранения в кэш ...

        return $ip;
    }
    // ...
}
```

- **Постоянный кэш:** Перед вызовом `gethostbyname()` проверяется, сохранен ли IP-адрес в файле кэша (`dns/` + MD5-хэш имени хоста). Кэш считается действительным, если не превышен `DNS_Config::CACHE_TTL_SECONDS` (по умолчанию 3600 секунд или 1 час).
- **Надежная валидация:** Разрешенный (или прочитанный из кэша) IP-адрес проверяется с помощью `filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)`, чтобы убедиться, что это действительный IPv4. Если разрешение не удается, выбрасывается `Query_Exception`.

### 8. `socket_manager.php`: Надежный менеджер UDP-соединений

Класс `Socket_Manager` инкапсулирует сложность создания, настройки и управления UDP-сокетом для связи с игровым сервером.

```php
// ...
final class Socket_Manager {
    private $socket = null;
    // ...
    private function Connect(): void {
        if (is_resource($this->socket))
            return;

        $context = stream_context_create([
            'socket' => ['so_rcvbuf' => Protocol::KERNEL_RECEIVE_BUFFER_SIZE] // Увеличивает буфер до 4MB
        ]);

        $this->socket = stream_socket_client(
            "udp://{$this->host}:{$this->port}", 
            $err_no, $err_str, 
            (float)ini_get("default_socket_timeout"), 
            STREAM_CLIENT_CONNECT, // Подключает сокет к удаленному адресу
            $context
        );

        if ($this->socket === false)
            throw new Connection_Exception("Could not create socket...");
    }
    // ...
}
```

- **`stream_socket_client` с `STREAM_CLIENT_CONNECT`:** Этот *флаг* указывает операционной системе "подключить" UDP-сокет к удаленному адресу. Хотя UDP является протоколом без установления соединения, "подключение" сокета позволяет оптимизировать производительность на уровне ядра, например, не нужно указывать удаленный адрес в каждом вызове `fwrite` или `stream_socket_recvfrom`, что приводит к меньшим накладным расходам.
- **Буфер приема ядра:** `stream_context_create` используется для увеличения размера буфера приема ядра (`so_rcvbuf`) до `Protocol::KERNEL_RECEIVE_BUFFER_SIZE` (4 МБ). Это крайне важно для предотвращения потери пакетов (переполнения буфера) при получении больших ответов, таких как подробные списки игроков с загруженных серверов.
- **RAII через `__destruct`:** Метод `Disconnect()` вызывается автоматически в деструкторе (`__destruct`), гарантируя закрытие сокета и освобождение ресурсов даже в случае исключений.
- **Динамический тайм-аут:** `Set_Timeout` точно настраивает тайм-ауты чтения/записи сокета с помощью `stream_set_timeout`, что является основой для логики *повторных попыток* и *backoff*.

### 9. `packet_builder.php`: Сборщик бинарных пакетов

Класс `Packet_Builder` отвечает за сериализацию данных запроса в специфический бинарный формат, который может понять сервер SA-MP/OMP.

```php
// ...
final class Packet_Builder {
    // ...
    private function Build_Header(): string {
        $packet = 'SAMP';
        $packet .= pack('c4', ...$this->ip_parts); // IP в 4 байтах
        $packet .= pack('v', $this->port); // Порт в 2 байтах (little-endian)

        return $packet;
    }
    
    public function Build(string $opcode): string {
        $packet = $this->Build_Header();
        $packet .= $opcode;

        if ($opcode === Opcode::PING->value)
            $packet .= random_bytes(4); // Случайная полезная нагрузка для PING
        
        return $packet;
    }
    // ...
}
```

- **`pack()` для бинарного формата:** Использует функцию `pack()` PHP для преобразования данных (IP, порт, длины строк) в их правильный бинарный формат, такой как `c4` для 4 байтов символов (IP) и `v` для 16-битного беззнакового целого числа (порт и длины), который является *little-endian*.
- **Стандартный заголовок:** `Build_Header()` создает 10-байтный заголовок 'SAMP', который предшествует всем пакетам.
- **Структура RCON:** `Build_Rcon` форматирует RCON-пакет с опкодом 'x', за которым следуют длина пароля, пароль, длина команды и сама команда.

### 10. `packet_parser.php`: Декодер пакетов с обработкой кодировки

Класс `Packet_Parser` является аналогом `Packet_Builder`, отвечающим за интерпретацию бинарных ответов, полученных от сервера, и их преобразование в структурированные данные PHP.

```php
// ...
final class Packet_Parser {
    private int $offset = Protocol::MIN_PACKET_LENGTH; // Начинается после заголовка (11 байт)
    // ...
    public function __construct(private readonly string $data) {
        // Начальная проверка заголовка 'SAMP'
        if (substr($this->data, 0, 4) !== 'SAMP' || strlen($this->data) < Protocol::MIN_PACKET_LENGTH)
            throw new Malformed_Packet_Exception("Invalid response header or packet too short.");
    }
    
    private function Extract_String(int $length_bytes): string {
        // ... логика для чтения длины и строки ...
        $string = substr($this->data, $this->offset, $length);
        $this->offset += $length;
        
        // **КРИТИЧЕСКОЕ ПРЕОБРАЗОВАНИЕ КОДИРОВКИ:** Серверы SA-MP/OMP используют Windows-1252
        return mb_convert_encoding($string, 'UTF-8', 'Windows-1252');
    }
    // ...
}
```

- **`offset` и `data_length`:** `offset` используется для отслеживания текущей позиции при чтении пакета, в то время как `data_length` предотвращает чтение за пределами буфера.
- **Проверка заголовка:** Конструктор проверяет "магическую строку" `SAMP` для немедленного отбрасывания некорректно сформированных пакетов.
- **`Extract_String()` - Важнейшее преобразование кодировки:** Это одна из самых важных функций. Протокол SA-MP передает строки в кодировке **Windows-1252**. Чтобы обеспечить правильное отображение специальных символов (таких как акценты или кириллица) в PHP-приложениях (которые обычно работают в UTF-8), применяется метод `mb_convert_encoding($string, 'UTF-8', 'Windows-1252')`.
- **Извлечение переменной длины:** Метод `Extract_String` поддерживает разные размеры префикса длины для строк (1, 2 или 4 байта), что делает его гибким для различных полей протокола.

### 11. `samp-query.php`: Основной класс (Полный оркестратор)

Класс `Samp_Query` является основной точкой входа и оркестратором всех операций. Он связывает все компоненты, управляет состоянием запроса, логикой *повторных попыток* и *тайм-аутами*.

#### Жизненный цикл запроса: Путешествие пакета

Весь процесс запроса к серверу следует тщательно организованной последовательности шагов, нацеленной на максимальную отказоустойчивость и производительность.

##### 1. Инициализация и разрешение домена

При создании экземпляра `Samp_Query`:
- **Быстрая проверка:** Конструктор проверяет параметры `$hostname` и `$port`. Любое несоответствие приводит к `Invalid_Argument_Exception`.
- **Очистка кэша DNS:** Вызывается `Domain_Resolver::Clean_Expired_Cache()` для гарантии, что будут использоваться только действительные и не истекшие записи DNS.
- **Разрешение IP:** `Domain_Resolver` используется для преобразования `$hostname` в IP-адрес (`$this->ip`). Этот IP кэшируется на диске для будущих запросов, и если разрешение не удается, выбрасывается `Query_Exception`.
- **Настройка ресурсов:** Инстанцируются `Logger`, `Socket_Manager` и `Packet_Builder`, подготавливая инфраструктуру для связи.

##### 2. `Fetch_Server_State()`: Кэш и критический запрос INFO/PING

Этот внутренний метод является гарантом производительности и согласованности, обеспечивая, чтобы основная информация о сервере (`Server_Info`) и `ping` всегда были актуальны перед любым основным запросом.

- **Основной кэш (5 секунд):** Перед началом любой связи проверяется, есть ли в `$this->cached_info` (объект `Server_Info` сервера) данные возрастом менее 5 секунд (по сравнению с `$this->last_successful_query`). Если данные свежие, функция немедленно возвращается, избегая ненужного сетевого трафика.
- **Критический запрос INFO:** Если кэш истек или пуст, вызывается метод `Attempt_Query` для получения данных `INFO`. Этот запрос помечается как **критический** (`true`), что запускает большее количество попыток и более щедрые *тайм-ауты*. Если ответ INFO недействителен после всех попыток, выбрасывается `Connection_Exception`.
- **Расчет пинга:** Если `$this->cached_ping` все еще равен null, выполняется быстрый запрос `PING` (`Execute_Query_Phase` с `Performance::FAST_PING_TIMEOUT`). Пинг рассчитывается как время, прошедшее до получения **первого** ответа, что обеспечивает точность.

##### 3. `Attempt_Query()`: Оптимизированная стратегия повторных попыток

Это мозг отказоустойчивости библиотеки, управляющий циклом повторных попыток высокого уровня для одного или нескольких `$jobs` (запросов опкодов).

- **Кэш ответов (2 секунды):** Сначала проверяется, есть ли ответы для любого из `$jobs` уже в `$this->response_cache` (возрастом менее 2.0 секунд). Это предотвращает ненужные *повторные попытки* для волатильных, но не критических данных.
- **Фаза быстрых повторных попыток:** Сначала библиотека пытается `Query::FAST_RETRY_ATTEMPTS` (по умолчанию 2) с меньшим *тайм-аутом* (`$timeout * 0.6`). Цель — получить ответ как можно быстрее, не внося значительных задержек.
- **Фаза стандартных повторных попыток с Backoff:** Если быстрой фазы недостаточно, цикл продолжается с оставшимися `Query::ATTEMPTS`. На этом этапе `$adjusted_timeout` постепенно увеличивается с каждой попыткой, давая серверу больше времени на ответ. Что еще важнее, `usleep()` вводит возрастающую задержку (на основе `Query::RETRY_DELAY_MS` и фактора увеличения) между вызовами `Execute_Query_Phase`, позволяя сети и серверу стабилизироваться.
- **Аварийные повторные попытки (для критических запросов):** Для `$jobs`, помеченных как `critical`, если все предыдущие попытки не увенчались успехом, для каждого задания индивидуально выполняется последняя *повторная попытка* с еще большим *тайм-аутом* (`$timeout * 2`). Это последний шанс получить жизненно важную информацию.

##### 4. `Execute_Query_Phase()`: Движок связи с определением пинга

Этот низкоуровневый метод — место, где происходит реальное взаимодействие с UDP-сокетом. Он управляет отправкой и получением пакетов для группы `$jobs` одновременно в одной сетевой фазе.

```php
// ... (внутри Execute_Query_Phase)
private function Execute_Query_Phase(array $jobs, ?int &$ping, float $timeout): array {
    $socket = $this->socket_manager->Get_Socket_Resource($timeout);
    stream_set_blocking($socket, false); // Неблокирующий сокет

    // Отправляет пакеты дважды немедленно для большей гарантии доставки UDP
    for ($i = 0; $i < 2; $i++) {
        foreach ($pending_jobs as $opcode)
            fwrite($socket, $this->packet_builder->Build($opcode->value));

        if ($i == 0)
            usleep(5000); // Небольшая задержка
    }

    $last_send_time = microtime(true);
    $current_retry_interval = Performance::INITIAL_RETRY_INTERVAL; // 0.08с
    
    while (!empty($pending_jobs) && (microtime(true) - $start_time) < $timeout) {
        $now = microtime(true);

        if (($now - $last_send_time) > $current_retry_interval) { // Логика повторной отправки с backoff
            // ... повторно отправляет ожидающие пакеты ...
            $current_retry_interval = min($current_retry_interval * Performance::BACKOFF_FACTOR, 0.2); // Увеличивает интервал повтора
        }

        $read = [$socket]; $write = $except = null

        if (stream_select($read, $write, $except, 0, 10000) > 0) { // Ожидает данные (макс. 10 мс)
            $response = stream_socket_recvfrom($socket, Protocol::UDP_READ_BUFFER_SIZE);
            // ... логика парсинга, расчета пинга и валидации ...
        }

        if (!empty($pending_jobs))
            usleep(1000); // Небольшая задержка для предотвращения загрузки ЦП
    }
    return $phase_results;
}
```

- **Неблокирующий сокет:** `stream_set_blocking($socket, false)` является обязательным. Это позволяет PHP отправлять пакеты и затем ожидать ответов, не блокируя выполнение, с помощью `stream_select`.
- **Двойная отправка для надежности:** Пакеты для всех `$pending_jobs` отправляются **дважды** подряд (с небольшой задержкой `usleep(5000)` между ними) в начале фазы. Эта практика является ключевой в протоколах UDP для значительного увеличения вероятности доставки в нестабильных сетях или с потерей пакетов, смягчая ненадежную природу UDP. Для `INFO` и `PING` во время *повторных попыток* в основном цикле выполняется дополнительная третья отправка.
- **Цикл приема с адаптивным Backoff:**
   - Основной цикл `while` продолжается до тех пор, пока все `$jobs` не будут завершены или не истечет *тайм-аут* фазы.
   - **Динамическая повторная отправка:** Если время, прошедшее с момента последней отправки (`$now - $last_send_time`), превышает `$current_retry_interval`, пакеты для `$pending_jobs` отправляются повторно. Затем `$current_retry_interval` увеличивается (`min($current_retry_interval * Performance::BACKOFF_FACTOR, 0.2)`), реализуя экспоненциальный *backoff*, который предотвращает перегрузку сервера и максимизирует шансы на получение ответа.
   - **Оптимизированный `stream_select`:** `stream_select($read, $write, $except, 0, 10000)` используется для ожидания данных не более 10 миллисекунд. Это позволяет библиотеке быть отзывчивой и обрабатывать пакеты по мере их поступления.
   - **Точное измерение пинга:** Когда получен **первый** действительный пакет (`$packets_received === 0`), `ping` рассчитывается с высокой точностью как разница между `microtime(true)` в начале отправки первой партии пакетов и точным временем получения **первого** действительного пакета.
- **Обработка и валидация ответа:** Полученные ответы декодируются `Packet_Parser`. Если обнаружен пакет `Malformed_Packet_Exception`, он логируется, и пакет немедленно отправляется на сервер для повторной попытки. Декодированный ответ затем проверяется `Validate_Response()`. Если он действителен, он добавляется в `$phase_results` и `$this->response_cache`.

##### 5. `Validate_Response()`: Слой семантической валидации

Этот критически важный метод, реализованный в классе `Samp_Query`, проверяет целостность и логическую согласованность декодированных данных перед их передачей пользователю.

```php
// ... (внутри Validate_Response)
private function Validate_Response($data, Opcode $opcode): bool {
    switch ($opcode) {
        case Opcode::INFO:
            // Гарантирует, что имя хоста не пустое и что количество игроков логично
            return $data instanceof Server_Info && $data->max_players > 0 && $data->players >= 0 && $data->players <= $data->max_players && !empty($data->hostname);
        
        case Opcode::RULES:
            if (!is_array($data))
                return false;

            // ...

            return true;
        // ... проверки для PLAYERS_DETAILED, PLAYERS_BASIC, PING ...
    }
}
```

- **Проверка по опкоду:** У каждого `Opcode` есть своя специфическая логика проверки. Например:
   - Для `Opcode::INFO`: Гарантирует, что `$data` является экземпляром `Server_Info`, что `$data->max_players > 0`, `$data->players` находится в диапазоне от 0 до `max_players`, и что `$data->hostname` не пустое.
   - Для `Opcode::RULES` или списков игроков: Проверяет, что возвращаемое значение является `array` и, если он не пуст, что первый элемент является экземпляром ожидаемой модели (`Server_Rule`, `Players_Detailed` и т.д.).
- **Надежность:** Если проверка не удалась, ответ считается недействительным и отбрасывается. Это заставляет систему продолжать попытки, как будто пакет так и не был получен, защищая приложение от поврежденных или несогласованных данных с сервера.

#### Расчет и управление адаптивным тайм-аутом

Библиотека реализует сложную стратегию *тайм-аута* для балансировки скорости и отказоустойчивости:

- **`Performance::METADATA_TIMEOUT`:** (0.8 секунды) Базовый *тайм-аут* для быстрых запросов, таких как `INFO` и `RULES`.
- **`Performance::PLAYER_LIST_BASE_TIMEOUT`:** (1.0 секунда) Базовый *тайм-аут* для запросов списка игроков.
- **`Performance::PING_MULTIPLIER`:** (2) Используется для корректировки *тайм-аута* на основе пинга.
- **Корректировка по пингу:** В методе `Fetch_Player_Data` *тайм-аут* для получения списка игроков настраивается динамически:
   ```
   Тайм-аут игроков = PLAYER_LIST_BASE_TIMEOUT + (Кэшированный пинг * PING_MULTIPLIER / 1000)
   ```
   Этот подход позволяет серверам с высокой задержкой (высоким пингом) иметь больший *тайм-аут*, увеличивая шанс на успешное получение полного списка игроков, который может быть большим и требовать времени на обработку сервером.
- **Ограничение тайм-аута:** `min($timeout, 2.0)` используется в нескольких вызовах для наложения максимального ограничения в 2.0 секунды на запросы метаданных, предотвращая чрезмерные ожидания.

#### Публичные методы запросов

| Метод | Подробное описание | Внутреннее поведение кэширования |
| :--- | :--- | :--- |
| `Get_All()` | **Рекомендуемый метод для общего использования.** Оркестрирует получение `INFO`, `RULES`, `PLAYERS_DETAILED` (или `PLAYERS_BASIC` в качестве резервного варианта) параллельно. Это минимизирует общее время запроса, так как пакеты отправляются почти одновременно, а ответы обрабатываются по мере поступления. Включает измерение общего `execution_time_ms`. | Использует кэш на 2.0с (`$this->response_cache`) для каждого опкода, запрашиваемого в параллельной фазе. |
| `Is_Online()` | Выполняет быстрый запрос `INFO` и возвращает `true`, если сервер отвечает действительным `Server_Info` в течение *тайм-аута*, в противном случае `false`. Надежен, использует критические *повторные попытки*. | Внутренне вызывает `Fetch_Server_State()`, который использует кэш на 5.0с для `INFO`. |
| `Get_Ping()` | Возвращает последний пинг сервера в миллисекундах. Если `cached_ping` равен null, принудительно выполняет специальный запрос `PING` с `Performance::FAST_PING_TIMEOUT` (0.3с) для быстрого измерения. | `ping` кэшируется и обновляется каждый раз, когда `Execute_Query_Phase` получает первый ответ. |
| `Get_Info()` | Возвращает объект `Server_Info` с такими деталями, как имя хоста, игровой режим, количество игроков и т.д. | Вызывает `Fetch_Server_State()`, который использует кэш на 5.0с. |
| `Get_Rules()` | Возвращает `array` объектов `Server_Rule`, содержащий все настроенные на сервере правила (например, `mapname`, `weburl`). Включает дополнительные *повторные попытки* в случае первоначального сбоя. | Использует кэш на 2.0с для `Opcode::RULES`. |
| `Get_Players_Detailed()` | Возвращает `array` объектов `Players_Detailed` (id, имя, счет, пинг для каждого игрока). **Важно:** Этот запрос игнорируется, если количество игроков на сервере (`$this->cached_info->players`) больше или равно `Query::LARGE_PLAYER_THRESHOLD` (по умолчанию 150) из-за риска длительных *тайм-аутов* или фрагментации пакетов. | Использует кэш на 2.0с для `Opcode::PLAYERS_DETAILED`. |
| `Get_Players_Basic()` | Возвращает `array` объектов `Players_Basic` (имя, счет для каждого игрока). Легче, чем подробный запрос. Обычно вызывается в качестве *резервного варианта*, если `Get_Players_Detailed()` не удался или был проигнорирован. | Использует кэш на 2.0с для `Opcode::PLAYERS_BASIC`. |

#### Связь RCON (`Send_Rcon`)

Метод `Send_Rcon(string $rcon_password, string $command)` позволяет отправлять команды в удаленную консоль сервера.

1.  **Проверка аргументов:** Выбрасывает `Invalid_Argument_Exception`, если пароль или команда пустые.
2.  **Изолированный сокет:** Создает новый экземпляр `Socket_Manager` (`$rcon_socket_manager`) для сессии RCON, изолируя ее от основного сокета запросов, чтобы избежать помех.
3.  **Аутентификация (`varlist`):** Перед отправкой реальной команды библиотека отправляет команду "varlist" (до 3 попыток) для аутентификации RCON-пароля. Если `Send_Single_Rcon_Request` возвращает `null` или пустой ответ, выбрасывается `Rcon_Exception`, указывая на сбой аутентификации или на то, что RCON не включен.
4.  **Отправка реальной команды:** После успешной аутентификации отправляется `$command`, также с до 3 попытками.
5.  **Обработка ответа:** `Packet_Parser::Parse_Rcon()` декодирует текстовый ответ RCON. Если сервер не возвращает текстовый ответ после всех попыток, возвращается общее сообщение об успехе.
6.  **Очистка:** Деструктор `$rcon_socket_manager` гарантирует, что сокет RCON будет закрыт после операции.

## Диагностика ошибок и исключений

Библиотека использует иерархию пользовательских исключений для чистой и предсказуемой обработки ошибок. В случае сбоя будет выброшено одно из следующих исключений.

### `Invalid_Argument_Exception`

**Причина:**
- **Пустое имя хоста:** `hostname`, предоставленный в конструкторе `Samp_Query`, является пустой строкой.
- **Недопустимый порт:** `port`, предоставленный в конструкторе, находится вне допустимого диапазона от 1 до 65535.
- **RCON:** RCON-пароль или RCON-команда, предоставленные для `Send_Rcon`, пустые.

### `Connection_Exception`

**Причина:** Сбой сети или отсутствие необходимого ответа.
- **Сбой разрешения домена:** `Domain_Resolver` не может преобразовать имя хоста в действительный IPv4.
- **Сбой создания сокета:** `Socket_Manager` не может создать или подключить UDP-сокет.
- **Сервер недоступен/оффлайн:** Сервер не ответил действительным пакетом `INFO` после всех попыток и *тайм-аутов* (включая аварийные *повторные попытки*), что обычно указывает на то, что сервер оффлайн, IP/порт неверны, или брандмауэр блокирует соединение.

### `Malformed_Packet_Exception`

**Причина:** Повреждение данных на уровне протокола.
- **Недопустимый заголовок:** `Packet_Parser` обнаруживает пакет, который не начинается с "магической строки" `SAMP` или имеет недостаточную общую длину.
- **Недопустимая структура пакета:** `Packet_Parser` обнаруживает несоответствия в бинарной структуре, например, длина строки, указывающая за пределы пакета.
- **Отказоустойчивость:** Это исключение часто обрабатывается внутри `Execute_Query_Phase` для немедленного запуска *повторной попытки*, но может быть проброшено дальше, если проблема сохраняется.

### `Rcon_Exception`

**Причина:** Ошибка во время RCON-связи.
- **Сбой аутентификации RCON:** Сервер не ответил на аутентификацию RCON (через команду `varlist`) после 3 попыток, что предполагает неверный пароль или отключенный RCON на сервере.
- **Сбой отправки RCON-команды:** Фактическая RCON-команда не получила ответа после 3 попыток.

## Лицензия

Copyright © **SA-MP Programming Community**

Данное программное обеспечение лицензируется в соответствии с условиями лицензии MIT ("Лицензия"); вы можете использовать это программное обеспечение в соответствии с условиями Лицензии. Копию Лицензии можно получить по адресу: [MIT License](https://opensource.org/licenses/MIT)

### Условия использования

#### 1. Предоставленные разрешения

Настоящая лицензия бесплатно предоставляет любому лицу, получающему копию данного программного обеспечения и связанных с ним файлов документации, следующие права:
* Использовать, копировать, изменять, объединять, публиковать, распространять, сублицензировать и/или продавать копии программного обеспечения без ограничений
* Разрешать лицам, которым предоставляется программное обеспечение, делать то же самое при соблюдении указанных ниже условий

#### 2. Обязательные условия

Все копии или существенные части программного обеспечения должны включать:
* Вышеуказанное уведомление об авторских правах
* Данное уведомление о разрешении
* Приведенное ниже заявление об отказе от ответственности

#### 3. Авторские права

Программное обеспечение и вся связанная с ним документация защищены законами об авторских правах. **SA-MP Programming Community** сохраняет за собой оригинальные авторские права на программное обеспечение.

#### 4. Отказ от гарантий и ограничение ответственности

ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ "КАК ЕСТЬ", БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ, ЯВНЫХ ИЛИ ПОДРАЗУМЕВАЕМЫХ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ГАРАНТИЯМИ ТОВАРНОЙ ПРИГОДНОСТИ, ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ И НЕНАРУШЕНИЯ ПРАВ.

НИ ПРИ КАКИХ ОБСТОЯТЕЛЬСТВАХ АВТОРЫ ИЛИ ПРАВООБЛАДАТЕЛИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ ЗА ЛЮБЫЕ ПРЕТЕНЗИИ, УБЫТКИ ИЛИ ИНУЮ ОТВЕТСТВЕННОСТЬ, БУДЬ ТО В СИЛУ ДОГОВОРА, ДЕЛИКТА ИЛИ ИНЫМ ОБРАЗОМ, ВОЗНИКАЮЩИЕ ИЗ, ИЗ-ЗА ИЛИ В СВЯЗИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ ИЛИ ИСПОЛЬЗОВАНИЕМ ИЛИ ИНЫМИ ДЕЙСТВИЯМИ С ПРОГРАММНЫМ ОБЕСПЕЧЕНИЕМ.

---

Для подробной информации о лицензии MIT посетите: https://opensource.org/licenses/MIT